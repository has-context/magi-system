			// Handle structured messages from containers via the dedicated channel
			socketInstance.on('process:message', (event: ProcessMessageEvent) => {
				setProcesses(prevProcesses => {
					const newProcesses = new Map(prevProcesses);
					const process = newProcesses.get(event.id);

					if (!process) return newProcesses;

					// Use the imported MagiMessage structure 
					const data = event.message;
					const messages = [...process.messages];
					const streamingEvent = data.event;
					const timestamp = streamingEvent.timestamp || new Date().toISOString();
					const eventType = streamingEvent.type;

					// Handle different event types
					if (eventType === 'command_start' || eventType === 'connected') {
						// User message - already handled in process:create but good as a fallback
						if ('command' in streamingEvent) {
							const content = streamingEvent.command || '';
							if (content && !messages.some(m => m.type === 'user' && m.content === content)) {
								messages.push({
									id: generateId(),
									processId: event.id,
									type: 'user',
									content: content,
									timestamp: timestamp,
									rawEvent: data
								});
							}
						}
					} else if (eventType === 'tool_start') {
						// Tool call message
						if ('tool_calls' in streamingEvent) {
							const toolCalls = streamingEvent.tool_calls || [];
							for (const toolCall of toolCalls) {
								const toolName = toolCall.function.name;
								let toolParams = {};
								try {
									toolParams = JSON.parse(toolCall.function.arguments);
								} catch (e) {
									console.error('Error parsing tool arguments:', e);
								}
								
								// Generate command representation for certain tool types
								let command = '';
								if (toolName === 'shell' || toolName === 'bash' || toolName === 'terminal') {
									// For shell commands, use the command parameter directly
									command = toolParams.command?.toString() || '';
								} else if (toolName === 'file_read' || toolName === 'read_file') {
									// For file reading tools
									command = `cat ${toolParams.path || toolParams.file_path || ''}`;
								} else if (toolName === 'file_write' || toolName === 'write_file') {
									// For file writing tools
									command = `echo '...' > ${toolParams.path || toolParams.file_path || ''}`;
								} else if (toolName === 'search' || toolName === 'web_search') {
									// For search tools
									command = `search: ${toolParams.query || ''}`;
								} else if (toolName === 'python') {
									// For Python code execution
									command = `python -c "${toolParams.code || ''}"`;
								}

								messages.push({
									id: generateId(),
									processId: event.id,
									type: 'tool_call',
									content: `Using ${toolName}`,
									timestamp: timestamp,
									toolName: toolName,
									toolParams: toolParams,
									command: command,
									rawEvent: data
								} as ToolCallMessage);
							}
						}
					} else if (eventType === 'tool_done') {
						// Tool result message
						if ('tool_calls' in streamingEvent && 'results' in streamingEvent) {
							const toolCalls = streamingEvent.tool_calls || [];
							const results = streamingEvent.results || {};
							
							for (const toolCall of toolCalls) {
								const toolName = toolCall.function.name;
								const result = results[toolCall.id] || {};
								
								messages.push({
									id: generateId(),
									processId: event.id,
									type: 'tool_result',
									content: `Result from ${toolName}`,
									timestamp: timestamp,
									toolName: toolName,
									result: result,
									rawEvent: data
								} as ToolResultMessage);
							}
						}
					} else if (eventType === 'message_start' || eventType === 'message_delta' ||
						eventType === 'message_complete') {
						// Assistant message
						if ('content' in streamingEvent) {
							const content = streamingEvent.content || '';
							const messageId = 'message_id' in streamingEvent ? streamingEvent.message_id : '';

							if (content) {
								// Handle streaming messages (delta/complete pairs)
								if (eventType === 'message_delta' && messageId) {
									// For delta messages, handle ordered deltas to build complete message
									const existingDeltaIndex = messages.findIndex(m =>
										m.message_id === messageId);

									// Get order if available, otherwise default to 0
									const order = 'order' in streamingEvent ? Number(streamingEvent.order) : 0;

									if (existingDeltaIndex >= 0) {
										// Get the existing message
										const existingMessage = messages[existingDeltaIndex];

										// Initialize deltaChunks if not existing
										if (!existingMessage.deltaChunks) {
											existingMessage.deltaChunks = {};
										}

										// Store this chunk at the correct order position
										existingMessage.deltaChunks[order] = content;

										// Rebuild complete content from ordered chunks
										const orderedKeys = Object.keys(existingMessage.deltaChunks)
											.map(Number)
											.sort((a, b) => a - b);

										// Concatenate all chunks in correct order
										const combinedContent = orderedKeys
											.map(key => existingMessage.deltaChunks![key])
											.join('');

										// Update the displayed content
										messages[existingDeltaIndex].content = combinedContent;
									} else {
										// Create new delta message with deltaChunks
										const deltaChunks: { [order: number]: string } = {};
										deltaChunks[order] = content;

										messages.push({
											id: generateId(),
											processId: event.id,
											type: 'assistant',
											content: content, // Initial content is just this chunk
											timestamp: timestamp,
											message_id: messageId,
											isDelta: true,
											order: order,
											deltaChunks: deltaChunks,
											rawEvent: data
										});
									}
								} else if (eventType === 'message_complete' && messageId) {
									// For complete messages, update or replace any existing delta with same message_id
									const existingIndex = messages.findIndex(m =>
										m.message_id === messageId);

									if (existingIndex >= 0) {
										// Update the existing message in place
										messages[existingIndex].content = content;
										messages[existingIndex].isDelta = false;
										messages[existingIndex].rawEvent = data;
									} else {
										// Add the complete message if no matching delta was found
										messages.push({
											id: generateId(),
											processId: event.id,
											type: 'assistant',
											content: content,
											timestamp: timestamp,
											message_id: messageId,
											rawEvent: data
										});
									}
								} else {
									// For other message types, just add normally but still include message_id if available
									messages.push({
										id: generateId(),
										processId: event.id,
										type: 'assistant',
										content: content,
										timestamp: timestamp,
										message_id: messageId || undefined, // Include message_id if available
										rawEvent: data
									});
								}
							}
						}
					} else if (eventType === 'error') {
						// Error message
						const errorMessage = 'error' in streamingEvent ? streamingEvent.error : 'An error occurred';
						messages.push({
							id: generateId(),
							processId: event.id,
							type: 'system',
							content: errorMessage,
							timestamp: timestamp,
							rawEvent: data
						});
					} else if (eventType === 'agent_start' || eventType === 'agent_updated') {
						// Extract agent information
						if (streamingEvent.agent && streamingEvent.agent.name) {
							// Update the process with agent name
							process.agentName = streamingEvent.agent.name;
						}

						// Check for parent-child relationship
						if ('parent_id' in streamingEvent && streamingEvent.parent_id) {
							const parentId = streamingEvent.parent_id;
							// Set this process as a sub-agent
							process.parentId = parentId;
							process.isSubAgent = true;

							// Update the parent process to track this as a child
							const parentProcess = newProcesses.get(parentId);
							if (parentProcess) {
								// Add this process ID to parent's childProcessIds if not already there
								if (!parentProcess.childProcessIds.includes(event.id)) {
									parentProcess.childProcessIds.push(event.id);
									newProcesses.set(parentId, parentProcess);

									// Add a system message to the parent process logs indicating sub-agent creation
									parentProcess.messages.push({
										id: generateId(),
										processId: parentId,
										type: 'system',
										content: `Started sub-agent: ${process.agentName || event.id}`,
										timestamp: new Date().toISOString()
									});
								}
							}
						}
					}

					// Turn off typing indicator for any response
					if (eventType === 'message_delta' || eventType === 'message_complete' ||
						eventType === 'tool_start' || eventType === 'tool_done') {
						process.isTyping = false;
					}

					// Update the process with the new messages
					newProcesses.set(event.id, {
						...process,
						messages: messages
					});

					return newProcesses;
				});
			});