/**
 * Browser utility functions for the MAGI system (WebSocket Client).
 *
 * This module communicates with the MAGI native messaging host bridge
 * running on the host machine via a WebSocket connection. It manages
 * browser sessions on a per-agent basis.
 */

import WebSocket from 'ws';
import { v4 as uuidv4 } from 'uuid'; // For generating unique request IDs

// --- Configuration ---
// Use environment variable or default. 'host.docker.internal' works for Docker Desktop.
const BRIDGE_WS_URL = process.env.MAGI_BRIDGE_WS_URL || 'ws://host.docker.internal:9001';
const WS_CONNECTION_TIMEOUT = 10000; // Time to wait for WebSocket connection (ms)
const WS_REQUEST_TIMEOUT = 35000; // Max time to wait for a response from bridge (ms)
const WS_RECONNECT_DELAY = 5000; // Delay before attempting reconnect (ms)

// --- WebSocket Connection Management (Singleton) ---
let wsClient: WebSocket | null = null;
let connectionPromise: Promise<WebSocket> | null = null;
let isConnecting = false;
let reconnectTimer: NodeJS.Timeout | null = null;
const pendingWsRequests = new Map<string, { resolve: (value: any) => void; reject: (reason?: any) => void; timeoutId: NodeJS.Timeout }>();

interface WebSocketCommand {
	wsRequestId: string; // ID generated by the WebSocket client
	command: string;
	tabId?: string; // Identifier for the browser tab session
	params?: any;
}

// Ensures a single WebSocket connection is established and reused.
function connectWebSocket(): Promise<WebSocket> {
	// If already connected and ready, return immediately
	if (wsClient && wsClient.readyState === WebSocket.OPEN) {
		return Promise.resolve(wsClient);
	}

	// If currently connecting, return the existing promise
	if (connectionPromise) {
		return connectionPromise;
	}

	console.log(`[browser_utils] Connecting to WebSocket bridge at ${BRIDGE_WS_URL}...`);
	isConnecting = true;
	clearTimeout(reconnectTimer!); // Clear any pending reconnect timer

	connectionPromise = new Promise((resolve, reject) => {
		const tempWs = new WebSocket(BRIDGE_WS_URL);
		let didConnect = false;

		const connectTimeout = setTimeout(() => {
			if (!didConnect) {
				console.error(`[browser_utils] WebSocket connection timed out after ${WS_CONNECTION_TIMEOUT / 1000}s.`);
				tempWs.terminate(); // Clean up the attempt
				reject(new Error('WebSocket connection timed out.'));
				connectionPromise = null; // Reset promise
				isConnecting = false;
				scheduleReconnect(); // Schedule reconnect on timeout
			}
		}, WS_CONNECTION_TIMEOUT);

		tempWs.on('open', () => {
			didConnect = true;
			clearTimeout(connectTimeout);
			console.log('[browser_utils] WebSocket connection established.');
			wsClient = tempWs;
			isConnecting = false;
			setupWebSocketListeners(wsClient);
			resolve(wsClient);
		});

		tempWs.on('error', (err) => {
			clearTimeout(connectTimeout); // Clear timeout on error
			console.error('[browser_utils] WebSocket connection error:', err.message);
			wsClient = null; // Ensure client is nullified
			connectionPromise = null; // Reset promise
			isConnecting = false;
			if (!didConnect) {
				reject(err);
			}
			// Schedule reconnect regardless of whether initial connection succeeded or failed later
			scheduleReconnect();
		});

		// 'close' listener is added in setupWebSocketListeners after successful connection
	});

	return connectionPromise;
}

// Sets up listeners for messages, close events, and pings.
function setupWebSocketListeners(ws: WebSocket) {
	ws.on('message', (data: Buffer) => {
		// console.log('[browser_utils] Received message:', data.toString());
		try {
			const response = JSON.parse(data.toString());
			if (!response.wsRequestId) {
				console.warn('[browser_utils] Received WebSocket message without wsRequestId:', response);
				return;
			}

			const pending = pendingWsRequests.get(response.wsRequestId);
			if (pending) {
				clearTimeout(pending.timeoutId); // Clear timeout
				pendingWsRequests.delete(response.wsRequestId); // Remove from map

				if (response.status === 'ok') {
					// console.log(`[browser_utils] Resolving WS request ${response.wsRequestId}`);
					pending.resolve(response.result);
				} else {
					console.error(`[browser_utils] Rejecting WS request ${response.wsRequestId} for tab ${response.tabId || 'N/A'}: ${response.error}`, response.details || '');
					const error = new Error(response.error || 'Unknown error from bridge/extension.');
					(error as any).details = response.details;
					(error as any).tabId = response.tabId; // Attach tabId if available
					pending.reject(error);
				}
			} else {
				console.warn(`[browser_utils] Received response for unknown or timed-out wsRequestId: ${response.wsRequestId}`);
			}
		} catch (error) {
			console.error('[browser_utils] Failed to parse WebSocket message:', error, data.toString());
		}
	});

	ws.on('close', (code, reason) => {
		console.warn(`[browser_utils] WebSocket connection closed. Code: ${code}, Reason: ${reason?.toString()}`);
		wsClient = null;
		connectionPromise = null; // Reset connection promise
		isConnecting = false;

		// Reject all pending requests on close
		pendingWsRequests.forEach((pending, wsRequestId) => {
			clearTimeout(pending.timeoutId);
			pending.reject(new Error(`WebSocket connection closed while request ${wsRequestId} was pending.`));
		});
		pendingWsRequests.clear();

		// Schedule reconnect attempt
		scheduleReconnect();
	});

	ws.on('ping', () => {
		// console.log('[browser_utils] Received ping from server.');
		ws.pong(); // Respond with pong
	});
}

// Schedules a WebSocket reconnection attempt.
function scheduleReconnect() {
	if (reconnectTimer) clearTimeout(reconnectTimer); // Clear existing timer
	if (!isConnecting && !wsClient) { // Only schedule if not already connecting or connected
		console.log(`[browser_utils] Scheduling WebSocket reconnect in ${WS_RECONNECT_DELAY / 1000}s...`);
		reconnectTimer = setTimeout(() => {
			connectWebSocket().catch(err => {
				console.error('[browser_utils] Reconnect attempt failed:', err.message);
				// No need to reschedule here, the error/close handler in connectWebSocket will do it
			});
		}, WS_RECONNECT_DELAY);
	}
}

// --- Command Sending Function (Internal) ---
// Sends a command over the WebSocket, including tabId if provided.
async function sendWsCommand(command: string, tabId: string, params: any = {}): Promise<any> {
	const ws = await connectWebSocket(); // Ensure connection exists or attempt to connect

	return new Promise((resolve, reject) => {
		const wsRequestId = uuidv4(); // Generate unique ID for this request

		const timeoutId = setTimeout(() => {
			if (pendingWsRequests.has(wsRequestId)) {
				pendingWsRequests.delete(wsRequestId);
				console.error(`[browser_utils] WebSocket request timed out for tab ${tabId}, command ${command} (ID: ${wsRequestId}) after ${WS_REQUEST_TIMEOUT / 1000}s.`);
				reject(new Error(`Request timed out waiting for response from bridge (Tab: ${tabId}, Command: ${command})`));
			}
		}, WS_REQUEST_TIMEOUT);

		pendingWsRequests.set(wsRequestId, { resolve, reject, timeoutId });

		const message: WebSocketCommand = { wsRequestId, command, tabId, params };

		try {
			ws.send(JSON.stringify(message));
			console.log(`[browser_utils] Sent command ${command} for tab ${tabId || 'N/A'} with WS ID ${wsRequestId}`);
		} catch (error) {
			clearTimeout(timeoutId);
			pendingWsRequests.delete(wsRequestId);
			console.error(`[browser_utils] Failed to send WebSocket command ${command} for tab ${tabId || 'N/A'}:`, error);
			reject(new Error(`Failed to send command over WebSocket: ${error instanceof Error ? error.message : String(error)}`));
		}
	});
}


// --- Agent Browser Session Class ---

/**
 * Manages a dedicated browser tab and interactions for a specific agent.
 */
export class AgentBrowserSession {
	private tabId: string;
	private initialized: boolean = false;
	private chromeTabId: number | null = null; // Store Chrome tabId if returned by initialize

	/**
	 * Creates a new browser session manager for a tab.
	 * @param tabId A unique identifier for the tab.
	 */
	constructor(tabId: string) {
		if (!tabId) {
			throw new Error('Tab ID cannot be empty.');
		}
		this.tabId = tabId;
		console.log(`[browser_utils] AgentBrowserSession created for tab: ${this.tabId}`);
	}

	/**
	 * Ensures the browser tab is created or identified in the extension.
	 * Must be called before other browser operations.
	 * @returns Promise<void> Resolves when initialization is confirmed by the extension.
	 */
	async initialize(): Promise<void> {
		if (this.initialized) {
			console.log(`[browser_utils] Tab ${this.tabId} session already initialized.`);
			return;
		}
		console.log(`[browser_utils] Initializing browser session for tab: ${this.tabId}...`);
		try {
			// The 'initialize_agent' command tells the extension to create/find the tab
			// and associate it with this tabId. It might return the chromeTabId.
			const result = await sendWsCommand('initialize_agent', this.tabId);
			this.initialized = true;
			this.chromeTabId = result?.tabId || null; // Store chromeTabId if provided
			console.log(`[browser_utils] Tab ${this.tabId} session initialized successfully.${this.chromeTabId ? ` Associated with Chrome tabId: ${this.chromeTabId}` : ''}`);
		} catch (error) {
			console.error(`[browser_utils] Failed to initialize browser session for tab ${this.tabId}:`, error);
			this.initialized = false; // Ensure it's marked as not initialized on failure
			throw error; // Re-throw the error to signal failure
		}
	}

	/** Helper to ensure initialization before proceeding */
	private async ensureInitialized(): Promise<void> {
		if (!this.initialized) {
			// Attempt initialization automatically if not done explicitly
			console.warn(`[browser_utils] Tab ${this.tabId} session not explicitly initialized. Attempting auto-initialization.`);
			await this.initialize();
			// If initialize() throws, this promise will be rejected.
		}
	}

	/** Logs errors consistently */
	private logError(operation: string, error: any, params?: any): string {
		const paramString = params ? ` with params ${JSON.stringify(params)}` : '';
		const errorMessage = `[browser_utils] Tab ${this.tabId} error during ${operation}${paramString}: ${error?.message || String(error)}`;
		console.error(errorMessage, error?.details || '');
		return `${errorMessage}${error?.details ? ` Details: ${JSON.stringify(error.details)}` : ''}`;
	}

	// --- Browser Control Methods ---

	async navigate(url: string, takeFocus?: false, waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' | 'commit'): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting navigation to: ${url}`);
		try {
			const result = await sendWsCommand('navigate', this.tabId, { url, takeFocus, waitUntil });
			return result + ' Recommend calling get_page_content() to refresh the view.';
		} catch (error: any) {
			return this.logError('navigate', error, { url, waitUntil });
		}
	}

	async get_page_content(allContent?: boolean): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting simplified page content...`);
		try {
			const result = await sendWsCommand('get_page_content', this.tabId, { allContent });
			// Response should be { simplifiedText, idMapSize }
			if (result && typeof result.simplifiedText === 'string') {
				console.log(`[browser_utils] Tab ${this.tabId}: Received simplified content (${result.simplifiedText.length} chars), map size: ${result.idMapSize}.`);
				return result.simplifiedText;
			} else {
				throw new Error('Invalid response format for get_page_content from bridge.');
			}
		} catch (error: any) {
			return this.logError('get_page_content', error) + '. Interaction map may be unavailable.';
		}
	}

	async get_page_url(): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting current page URL...`);
		try {
			const url = await sendWsCommand('get_url', this.tabId);
			return String(url); // Ensure it's a string
		} catch (error: any) {
			return this.logError('get_page_url', error);
		}
	}

	async screenshot(
		type: 'viewport' | 'page' | 'element' = 'viewport',
		elementId?: number,
		): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting ${type} ${elementId ?? ''} screenshot...`);
		try {
			// Take the screenshot - tell the extension to handle tab activation and restoration
			const result = await sendWsCommand('screenshot', this.tabId, {
				type,
				elementId,
				preserveFocus: true // Tell the extension to preserve the current active tab focus
			});

			if (!result?.imageDataUrl) { // Check for data
				throw new Error('No image data in screenshot response from bridge.');
			}

			// Import necessary modules
			const { createImageFromBase64, processImage } = await import('./image_utils.js');
			const { get_output_dir, write_unique_file } = await import('./file_utils.js');
			const path = await import('path');

			// Convert base64 to buffer and optimize the image
			const imageBuffer = await createImageFromBase64(result.imageDataUrl);
			const processedImage = await processImage(imageBuffer);

			// Create a unique filename with timestamp
			const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
			const screenshotsDir = get_output_dir('screenshots');
			const filename = `${timestamp}_${this.tabId}_${type}${elementId ? `_element_${elementId}` : ''}.jpg`;
			const screenshotPath = path.join(screenshotsDir, filename);

			// Save the processed image to a file
			const saveResult = write_unique_file(screenshotPath, processedImage);
			console.log(`[browser_utils] Screenshot saved: ${saveResult}`);

			return saveResult;
		} catch (error: any) {
			return this.logError('screenshot', error, { type, elementId });
		}
	}

	async js_evaluate(code: string): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting JavaScript evaluation: ${code.substring(0, 100)}${code.length > 100 ? '...' : ''}`);
		try {
			const result = await sendWsCommand('js_evaluate', this.tabId, { code });
			return String(result);
		} catch (error: any) {
			return this.logError('js_evaluate', error, { code: code.substring(0, 50) + '...' });
		}
	}

	async type(text: string): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting to type text: ${text}`);
		try {
			const result = await sendWsCommand('type', this.tabId, { text });
			return String(result);
		} catch (error: any) {
			return this.logError('type', error, { text });
		}
	}

	async press(keys: string): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting to press keys: ${keys}`);
		try {
			const result = await sendWsCommand('press', this.tabId, { keys });
			return String(result);
		} catch (error: any) {
			return this.logError('press', error, { keys });
		}
	}

	/**
	 * Lists all open browser tabs across all windows
	 * @returns Promise resolving to a JSON string with tab information
	 */
	async listOpenTabs(): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting list of all open tabs...`);
		try {
			const result = await sendWsCommand('list_open_tabs', this.tabId);
			// Format the tab data for easier consumption
			if (result.tabs && Array.isArray(result.tabs)) {
				return JSON.stringify({
					count: result.tabs.length,
					tabs: result.tabs.map((tab: any) => ({
						id: tab.id,
						title: tab.title || 'Untitled',
						url: tab.url || '',
						active: tab.active || false,
						windowId: tab.windowId
					}))
				}, null, 2);
			}
			return String(result);
		} catch (error: any) {
			return this.logError('listOpenTabs', error);
		}
	}

	/**
	 * Focuses on a specific browser tab by its Chrome tab ID
	 * @param chromeTabId The Chrome tab ID to focus
	 * @returns Promise resolving to a result message
	 */
	async focusTab(chromeTabId: number): Promise<string> {
		await this.ensureInitialized();
		if (typeof chromeTabId !== 'number' || chromeTabId <= 0) {
			const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Invalid Chrome tab ID (${chromeTabId}).`;
			console.error(errorMsg);
			return Promise.resolve(errorMsg);
		}
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting to focus on tab ${chromeTabId}...`);
		try {
			const result = await sendWsCommand('focus_tab', this.tabId, { chromeTabId });
			return String(result);
		} catch (error: any) {
			return this.logError('focusTab', error, { chromeTabId });
		}
	}

	async interactElement(
		elementId: number,
		action: 'click' | 'fill' | 'check' | 'hover' | 'focus' | 'scroll' | 'select_option',
		value?: string, // Used for fill, select_option
		checked?: boolean // Used for check
	): Promise<string> {
		await this.ensureInitialized();
		if (typeof elementId !== 'number' || elementId <= 0) {
			const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Invalid elementId (${elementId}) provided for action '${action}'.`;
			console.error(errorMsg);
			return Promise.resolve(errorMsg); // Return error string directly
		}
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting action '${action}' on element ID ${elementId}...`);
		try {
			const result = await sendWsCommand('interact_element', this.tabId, { elementId, action, value, checked });
			let message = String(result);
			// Add recommendations based on action
			if (!message.startsWith('[browser_utils] Error:') && !message.toLowerCase().includes('error')) {
				switch (action) {
					case 'click':
					case 'select_option':
						message += ' IMPORTANT: Page state might have changed. Consider calling get_page_content().';
						break;
					case 'hover':
						message += ' Tooltips or menus might now be visible. Consider calling get_page_content().';
						break;
					case 'focus':
						message += " Subsequent 'press' or 'type' actions may target this element.";
						break;
				}
			}
			return message;
		} catch (error: any) {
			return this.logError(`interactElement (${action})`, error, { elementId, value, checked });
		}
	}

	async clickElement(elementId: number): Promise<string> {
		return this.interactElement(elementId, 'click');
	}

	async fillField(elementId: number, value: string): Promise<string> {
		if (value === undefined || value === null) {
			return `[browser_utils] Tab ${this.tabId}: Error: 'value' parameter must be provided for 'fillField'.`;
		}
		return this.interactElement(elementId, 'fill', value);
	}

	async checkElement(elementId: number, checked: boolean): Promise<string> {
		if (checked === undefined || checked === null) {
			return `[browser_utils] Tab ${this.tabId}: Error: 'checked' parameter (true/false) must be provided for 'checkElement'.`;
		}
		return this.interactElement(elementId, 'check', undefined, checked);
	}

	async hoverElement(elementId: number): Promise<string> {
		return this.interactElement(elementId, 'hover');
	}

	async focusElement(elementId: number): Promise<string> {
		return this.interactElement(elementId, 'focus');
	}

	async scrollElement(elementId: number): Promise<string> {
		return this.interactElement(elementId, 'scroll');
	}

	async selectOption(elementId: number, value: string): Promise<string> {
		if (value === undefined || value === null) {
			return `[browser_utils] Tab ${this.tabId}: Error: 'value' parameter (option value, text, or label) must be provided for 'selectOption'.`;
		}
		return this.interactElement(elementId, 'select_option', value);
	}

	/**
	 * Switches the agent's tab or focuses on a specific tab
	 * @param type Type of tab operation to perform
	 * @param tabId Tab ID for 'id' or 'focus' operations
	 * @returns Result message from the bridge/extension or an error message string
	 */
	async switchTab(
		type: 'active' | 'new' | 'id' | 'focus',
		tabId?: string,
	): Promise<string> {
		await this.ensureInitialized();
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting tab operation '${type}'...`);
		
		try {
			// Handle the focus case directly using existing focusTab method
			if (type === 'focus' && tabId) {
				const chromeTabId = Number(tabId);
				if (isNaN(chromeTabId) || chromeTabId <= 0) {
					const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Invalid Chrome tab ID (${tabId}) for focus operation.`;
					console.error(errorMsg);
					return errorMsg;
				}
				return await this.focusTab(chromeTabId);
			}
			
			// Handle other tab switch operations
			const result = await sendWsCommand('switch_tab', this.tabId, {
				type,
				tabId,
			});

			this.initialized = true;
			this.chromeTabId = result?.tabId || null; // Store chromeTabId if provided
			return String(result);
		} catch (error: any) {
			return this.logError(type === 'focus' ? 'focusTab' : 'switchTab', error);
		}
	}

	/**
	 * Closes the dedicated browser tab and cleans up resources on the extension side.
	 * @returns Confirmation message or error.
	 */
	async closeSession(): Promise<string> {
		// No need to ensureInitialized, we want to close even if initialization failed
		console.log(`[browser_utils] Tab ${this.tabId}: Requesting session closure...`);
		try {
			const result = await sendWsCommand('close_agent_session', this.tabId);
			this.initialized = false; // Mark as not initialized after closing
			this.chromeTabId = null;
			console.log(`[browser_utils] Tab ${this.tabId} session closed successfully.`);
			return String(result);
		} catch (error: any) {
			// Still mark as uninitialized even if close command fails (e.g., tab already gone)
			this.initialized = false;
			this.chromeTabId = null;
			return this.logError('closeSession', error);
		}
	}
}

// --- Tool Definition Helper (If used by your framework) ---
// Keep these if your agent framework uses them to define tool schemas.
// Note: The actual functions called are now methods on AgentBrowserSession instance.
// You'll need to adapt how your agent framework gets and uses these tools.
// It should now call `getAgentBrowserSession(agentId)` and then use the methods
// on the returned session object.

// Example:
// const agentSession = getAgentBrowserSession('agent-007');
// await agentSession.initialize();
// const content = await agentSession.get_page_content();
// const navResult = await agentSession.navigate('https://google.com');

// --- Factory Function for Agent Sessions ---

/**
 * Creates or retrieves a browser session manager for a specific tab.
 *
 * @param tabId A unique identifier for the tab.
 * @returns An AgentBrowserSession instance for the given tabId.
 */
export function getAgentBrowserSession(tabId: string): AgentBrowserSession {
	// In this simple setup, we just create a new instance each time.
	// You could add caching here if needed, but ensure proper lifecycle management.
	return new AgentBrowserSession(tabId);
}


// --- Initial Connection Attempt ---
// Attempt to connect when the module loads. Errors will be handled by reconnect logic.
connectWebSocket().catch(err => {
	console.error('[browser_utils] Initial WebSocket connection failed:', err.message);
	// Reconnect will be scheduled by the error/close handler in connectWebSocket
});

// --- Graceful Shutdown ---
// Optional: Attempt to close sessions on exit, though this might not always run.
/*
process.on('SIGINT', async () => {
    console.log('[browser_utils] Received SIGINT. Attempting to close active sessions...');
    // You would need a way to track active sessions if you implement caching
    // for AgentBrowserSession instances. For now, this is conceptual.
    // Example: await Promise.all(activeSessions.map(s => s.closeSession()));
    if (wsClient) {
        wsClient.close();
    }
    process.exit(0);
});
*/
