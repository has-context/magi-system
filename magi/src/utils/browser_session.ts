/**
 * Browser utility functions for the MAGI system (WebSocket Client).
 *
 * This module communicates with the MAGI native messaging host bridge
 * running on the host machine via a WebSocket connection. It manages
 * browser sessions on a per-agent basis.
 */

import WebSocket from 'ws';
import { v4 as uuidv4 } from 'uuid'; // For generating unique request IDs

// --- Configuration ---
// Use environment variable or default. 'host.docker.internal' works for Docker Desktop.
const BRIDGE_WS_URL =
    process.env.MAGI_BRIDGE_WS_URL || 'ws://host.docker.internal:9001';
const WS_CONNECTION_TIMEOUT = 10000; // Time to wait for WebSocket connection (ms)
const WS_REQUEST_TIMEOUT = 35000; // Max time to wait for a response from bridge (ms)
const WS_RECONNECT_DELAY = 5000; // Delay before attempting reconnect (ms)

// --- WebSocket Connection Management (Singleton) ---
let wsClient: WebSocket | null = null;
let connectionPromise: Promise<WebSocket> | null = null;
let isConnecting = false;
let reconnectTimer: NodeJS.Timeout | null = null;
const pendingWsRequests = new Map<
    string,
    {
        resolve: (value: any) => void;
        reject: (reason?: any) => void;
        timeoutId: NodeJS.Timeout;
    }
>();

interface WebSocketCommand {
    wsRequestId: string; // ID generated by the WebSocket client
    command: string;
    tabId?: string; // Identifier for the browser tab session
    params?: any;
}

// Ensures a single WebSocket connection is established and reused.
function connectWebSocket(): Promise<WebSocket> {
    // If already connected and ready, return immediately
    if (wsClient && wsClient.readyState === WebSocket.OPEN) {
        return Promise.resolve(wsClient);
    }

    // If currently connecting, return the existing promise
    if (connectionPromise) {
        return connectionPromise;
    }

    console.log(
        `[browser_utils] Connecting to WebSocket bridge at ${BRIDGE_WS_URL}...`
    );
    isConnecting = true;
    clearTimeout(reconnectTimer!); // Clear any pending reconnect timer

    connectionPromise = new Promise((resolve, reject) => {
        const tempWs = new WebSocket(BRIDGE_WS_URL);
        let didConnect = false;

        const connectTimeout = setTimeout(() => {
            if (!didConnect) {
                console.error(
                    `[browser_utils] WebSocket connection timed out after ${WS_CONNECTION_TIMEOUT / 1000}s.`
                );
                tempWs.terminate(); // Clean up the attempt
                reject(new Error('WebSocket connection timed out.'));
                connectionPromise = null; // Reset promise
                isConnecting = false;
                scheduleReconnect(); // Schedule reconnect on timeout
            }
        }, WS_CONNECTION_TIMEOUT);

        tempWs.on('open', () => {
            didConnect = true;
            clearTimeout(connectTimeout);
            console.log('[browser_utils] WebSocket connection established.');
            wsClient = tempWs;
            isConnecting = false;
            setupWebSocketListeners(wsClient);
            resolve(wsClient);
        });

        tempWs.on('error', err => {
            clearTimeout(connectTimeout); // Clear timeout on error
            console.error(
                '[browser_utils] WebSocket connection error:',
                err.message
            );
            wsClient = null; // Ensure client is nullified
            connectionPromise = null; // Reset promise
            isConnecting = false;
            if (!didConnect) {
                reject(err);
            }
            // Schedule reconnect regardless of whether initial connection succeeded or failed later
            scheduleReconnect();
        });

        // 'close' listener is added in setupWebSocketListeners after successful connection
    });

    return connectionPromise;
}

// Sets up listeners for messages, close events, and pings.
function setupWebSocketListeners(ws: WebSocket) {
    ws.on('message', (data: Buffer) => {
        // console.log('[browser_utils] Received message:', data.toString());
        try {
            const response = JSON.parse(data.toString());
            if (!response.wsRequestId) {
                console.warn(
                    '[browser_utils] Received WebSocket message without wsRequestId:',
                    response
                );
                return;
            }

            const pending = pendingWsRequests.get(response.wsRequestId);
            if (pending) {
                clearTimeout(pending.timeoutId); // Clear timeout
                pendingWsRequests.delete(response.wsRequestId); // Remove from map

                if (response.status === 'ok') {
                    // console.log(`[browser_utils] Resolving WS request ${response.wsRequestId}`);
                    pending.resolve(response.result);
                } else {
                    console.error(
                        `[browser_utils] Rejecting WS request ${response.wsRequestId} for tab ${response.tabId || 'N/A'}: ${response.error}`,
                        response.details || ''
                    );
                    const error = new Error(
                        response.error || 'Unknown error from bridge/extension.'
                    );
                    (error as any).details = response.details;
                    (error as any).tabId = response.tabId; // Attach tabId if available
                    pending.reject(error);
                }
            } else {
                console.warn(
                    `[browser_utils] Received response for unknown or timed-out wsRequestId: ${response.wsRequestId}`
                );
            }
        } catch (error) {
            console.error(
                '[browser_utils] Failed to parse WebSocket message:',
                error,
                data.toString()
            );
        }
    });

    ws.on('close', (code, reason) => {
        console.warn(
            `[browser_utils] WebSocket connection closed. Code: ${code}, Reason: ${reason?.toString()}`
        );
        wsClient = null;
        connectionPromise = null; // Reset connection promise
        isConnecting = false;

        // Reject all pending requests on close
        pendingWsRequests.forEach((pending, wsRequestId) => {
            clearTimeout(pending.timeoutId);
            pending.reject(
                new Error(
                    `WebSocket connection closed while request ${wsRequestId} was pending.`
                )
            );
        });
        pendingWsRequests.clear();

        // Schedule reconnect attempt
        scheduleReconnect();
    });

    ws.on('ping', () => {
        // console.log('[browser_utils] Received ping from server.');
        ws.pong(); // Respond with pong
    });
}

// Schedules a WebSocket reconnection attempt.
function scheduleReconnect() {
    if (reconnectTimer) clearTimeout(reconnectTimer); // Clear existing timer
    if (!isConnecting && !wsClient) {
        // Only schedule if not already connecting or connected
        console.log(
            `[browser_utils] Scheduling WebSocket reconnect in ${WS_RECONNECT_DELAY / 1000}s...`
        );
        reconnectTimer = setTimeout(() => {
            connectWebSocket().catch(err => {
                console.error(
                    '[browser_utils] Reconnect attempt failed:',
                    err.message
                );
                // No need to reschedule here, the error/close handler in connectWebSocket will do it
            });
        }, WS_RECONNECT_DELAY);
    }
}

// --- Command Sending Function (Internal) ---
// Sends a command over the WebSocket, including tabId if provided.
async function sendWsCommand(
    command: string,
    tabId: string,
    params: any = {}
): Promise<any> {
    const ws = await connectWebSocket(); // Ensure connection exists or attempt to connect

    return new Promise((resolve, reject) => {
        const wsRequestId = uuidv4(); // Generate unique ID for this request

        const timeoutId = setTimeout(() => {
            if (pendingWsRequests.has(wsRequestId)) {
                pendingWsRequests.delete(wsRequestId);
                console.error(
                    `[browser_utils] WebSocket request timed out for tab ${tabId}, command ${command} (ID: ${wsRequestId}) after ${WS_REQUEST_TIMEOUT / 1000}s.`
                );
                reject(
                    new Error(
                        `Request timed out waiting for response from bridge (Tab: ${tabId}, Command: ${command})`
                    )
                );
            }
        }, WS_REQUEST_TIMEOUT);

        pendingWsRequests.set(wsRequestId, { resolve, reject, timeoutId });

        const message: WebSocketCommand = {
            wsRequestId,
            command,
            tabId,
            params,
        };

        try {
            ws.send(JSON.stringify(message));
            console.log(
                `[browser_utils] Sent command ${command} for tab ${tabId || 'N/A'} with WS ID ${wsRequestId}`
            );
        } catch (error) {
            clearTimeout(timeoutId);
            pendingWsRequests.delete(wsRequestId);
            console.error(
                `[browser_utils] Failed to send WebSocket command ${command} for tab ${tabId || 'N/A'}:`,
                error
            );
            reject(
                new Error(
                    `Failed to send command over WebSocket: ${error instanceof Error ? error.message : String(error)}`
                )
            );
        }
    });
}

// --- Agent Browser Session Class ---

/**
 * Manages a dedicated browser tab and interactions for a specific agent.
 */
export class AgentBrowserSession {
    private tabId: string;
    private startUrl?: string;
    private initialized: boolean = false;
    private chromeTabId: number | null = null; // Store Chrome tabId if returned by initialize

    /**
     * Creates a new browser session manager for a tab.
     * @param tabId A unique identifier for the tab.
     */
    constructor(tabId: string, startUrl?: string) {
        if (!tabId) {
            throw new Error('Tab ID cannot be empty.');
        }
        this.tabId = tabId;
        if (startUrl) {
            this.startUrl = startUrl;
        }
        console.log(
            `[browser_utils] AgentBrowserSession created for tab: ${this.tabId} ${this.startUrl ? `with start URL: ${this.startUrl}` : ''}`
        );
    }

    /**
     * Ensures the browser tab is created or identified in the extension.
     * Must be called before other browser operations.
     * @returns Promise<void> Resolves when initialization is confirmed by the extension.
     */
    async initialize(): Promise<void> {
        if (this.initialized) {
            console.log(
                `[browser_utils] Tab ${this.tabId} session already initialized.`
            );
            return;
        }
        console.log(
            `[browser_utils] Initializing browser session for tab: ${this.tabId}...`
        );
        try {
            // The 'initialize_agent' command tells the extension to create/find the tab
            // and associate it with this tabId. It might return the chromeTabId.
            const result = await sendWsCommand('initialize_agent', this.tabId, {
                startUrl: this.startUrl,
            });
            this.initialized = true;
            this.chromeTabId = result?.tabId || null; // Store chromeTabId if provided
            console.log(
                `[browser_utils] Tab ${this.tabId} session initialized successfully.${this.chromeTabId ? ` Associated with Chrome tabId: ${this.chromeTabId}` : ''}`
            );
        } catch (error) {
            console.error(
                `[browser_utils] Failed to initialize browser session for tab ${this.tabId}:`,
                error
            );
            this.initialized = false; // Ensure it's marked as not initialized on failure
            throw error; // Re-throw the error to signal failure
        }
    }

    /** Helper to ensure initialization before proceeding */
    private async ensureInitialized(): Promise<void> {
        if (!this.initialized) {
            // Attempt initialization automatically if not done explicitly
            console.warn(
                `[browser_utils] Tab ${this.tabId} session not explicitly initialized. Attempting auto-initialization.`
            );
            await this.initialize();
            // If initialize() throws, this promise will be rejected.
        }
    }

    /** Logs errors consistently */
    private logError(operation: string, error: any, params?: any): string {
        const paramString = params
            ? ` with params ${JSON.stringify(params)}`
            : '';
        const errorMessage = `[browser_utils] Tab ${this.tabId} error during ${operation}${paramString}: ${error?.message || String(error)}`;
        console.error(errorMessage, error?.details || '');
        return `${errorMessage}${error?.details ? ` Details: ${JSON.stringify(error.details)}` : ''}`;
    }

    // --- Browser Control Methods ---

    async navigate(
        url: string,
        takeFocus?: false,
        waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' | 'commit'
    ): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting navigation to: ${url}`
        );
        try {
            const result = await sendWsCommand('navigate', this.tabId, {
                url,
                takeFocus,
                waitUntil,
            });
            return result;
        } catch (error: any) {
            return this.logError('navigate', error, { url, waitUntil });
        }
    }

    async get_page_content(
        type: 'interactive' | 'markdown' | 'html'
    ): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting page content as type: ${type}...`
        );
        try {
            // The extension should handle the different types and return the appropriate content string directly.
            // For 'markdown', the extension should return the raw HTML, and the conversion happens in browser_utils.ts.
            // However, to simplify, let's assume the extension handles 'interactive' and 'html' directly,
            // and we request 'html' when 'markdown' is needed by the caller (browser_utils.ts).
            const requestedTypeForExtension =
                type === 'markdown' ? 'html' : type;
            const result = await sendWsCommand('get_page_content', this.tabId, {
                type: requestedTypeForExtension,
            });

            // Expect the result to be the content string directly for 'interactive' and 'html'
            if (typeof result === 'string') {
                console.log(
                    `[browser_utils] Tab ${this.tabId}: Received ${requestedTypeForExtension} content (${result.length} chars).`
                );
                return result;
            } else if (
                type === 'interactive' &&
                result &&
                typeof result.simplifiedText === 'string'
            ) {
                // Handle potential old format for interactive temporarily if needed
                console.log(
                    `[browser_utils] Tab ${this.tabId}: Received interactive content (legacy format) (${result.simplifiedText.length} chars), map size: ${result.idMapSize}.`
                );
                return result.simplifiedText;
            } else {
                throw new Error(
                    `Invalid response format for get_page_content (type: ${type}) from bridge. Expected string, got: ${typeof result}`
                );
            }
        } catch (error: any) {
            return (
                this.logError(`get_page_content (type: ${type})`, error) +
                '. Content may be unavailable.'
            );
        }
    }

    async get_page_url(): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting current page URL...`
        );
        try {
            const url = await sendWsCommand('get_url', this.tabId);
            return String(url); // Ensure it's a string
        } catch (error: any) {
            return this.logError('get_page_url', error);
        }
    }

    async screenshot(
        type: 'viewport' | 'page' | 'element' = 'viewport',
        opts: {
            elementId?: number;
            includeCoreTabs?: boolean;
        } = {}
    ): Promise<any> {
        await this.ensureInitialized();
        const { elementId, includeCoreTabs = true } = opts;
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting ${type} ${elementId ?? ''} screenshot (with${includeCoreTabs ? '' : 'out'} core tabs)...`
        );
        try {
            // Take the screenshot - tell the extension to handle tab activation and restoration
            const result = await sendWsCommand('screenshot', this.tabId, {
                type,
                elementId,
                preserveFocus: true, // Tell the extension to preserve the current active tab focus
                includeCoreTabs, // Include core tabs information in a single request
            });

            return result;

            /*if (!result?.imageDataUrl) { // Check for data
				throw new Error('No image data in screenshot response from bridge.');
			}

			// Import necessary modules
			const { createImageFromBase64, processImage, createBase64FromImage } = await import('./image_utils.js');

			// Convert base64 to buffer and optimize the image
			const imageBuffer = await createImageFromBase64(result.imageDataUrl);
			const processedImage = await processImage(imageBuffer);



			return createBase64FromImage(processedImage); // Return the base64 data URL
			*/
        } catch (error: any) {
            return this.logError('screenshot', error, { type, elementId });
        }
    }

    async js_evaluate(code: string): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting JavaScript evaluation: ${code.substring(0, 100)}${code.length > 100 ? '...' : ''}`
        );
        try {
            const result = await sendWsCommand('js_evaluate', this.tabId, {
                code,
            });
            console.log(
                `[browser_session] Tab ${this.tabId}: js_evaluate received result:`,
                result
            ); // Added log
            return String(result);
        } catch (error: any) {
            console.error(
                `[browser_session] Tab ${this.tabId}: js_evaluate caught error:`,
                error
            ); // Added log
            return this.logError('js_evaluate', error, {
                code: code.substring(0, 50) + '...',
            });
        }
    }

    async type(text: string): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting to type text: ${text}`
        );
        try {
            const result = await sendWsCommand('type', this.tabId, { text });
            return String(result);
        } catch (error: any) {
            return this.logError('type', error, { text });
        }
    }

    async press(keys: string): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting to press keys: ${keys}`
        );
        try {
            const result = await sendWsCommand('press', this.tabId, { keys });
            return String(result);
        } catch (error: any) {
            return this.logError('press', error, { keys });
        }
    }

    async scroll_to(
        mode: 'page_down' | 'page_up' | 'bottom' | 'top' | 'coordinates',
        x?: number,
        y?: number
    ): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting to scroll (${mode}) to: ${{ x, y }}`
        );
        try {
            const result = await sendWsCommand('scroll_to', this.tabId, {
                mode,
                x,
                y,
            });
            return String(result);
        } catch (error: any) {
            return this.logError('scroll_to', error, { mode, x, y });
        }
    }

    async click_at(
        x: number,
        y: number,
        button?: 'left' | 'middle' | 'right' | 'back' | 'forward'
    ): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting to click at: ${{ x, y, button }}`
        );
        try {
            const result = await sendWsCommand('click_at', this.tabId, {
                x,
                y,
                button,
            });
            return String(result);
        } catch (error: any) {
            return this.logError('click_at', error, { x, y });
        }
    }

    /**
     * Lists all open browser tabs across all windows
     * @returns Promise resolving to a JSON string with tab information
     */
    async listOpenTabs(): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting list of all open tabs...`
        );
        try {
            const result = await sendWsCommand('list_open_tabs', this.tabId);
            // Format the tab data for easier consumption
            if (result.tabs && Array.isArray(result.tabs)) {
                return JSON.stringify(
                    {
                        count: result.tabs.length,
                        tabs: result.tabs.map((tab: any) => ({
                            id: tab.id,
                            title: tab.title || 'Untitled',
                            url: tab.url || '',
                            active: tab.active || false,
                            windowId: tab.windowId,
                        })),
                    },
                    null,
                    2
                );
            }
            return String(result);
        } catch (error: any) {
            return this.logError('listOpenTabs', error);
        }
    }

    /**
     * Focuses on a specific browser tab by its Chrome tab ID
     * @param chromeTabId The Chrome tab ID to focus
     * @returns Promise resolving to a result message
     */
    async focusTab(chromeTabId: number): Promise<string> {
        await this.ensureInitialized();
        if (typeof chromeTabId !== 'number' || chromeTabId <= 0) {
            const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Invalid Chrome tab ID (${chromeTabId}).`;
            console.error(errorMsg);
            return Promise.resolve(errorMsg);
        }
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting to focus on tab ${chromeTabId}...`
        );
        try {
            const result = await sendWsCommand('focus_tab', this.tabId, {
                chromeTabId,
            });
            return String(result);
        } catch (error: any) {
            return this.logError('focusTab', error, { chromeTabId });
        }
    }

    async interactElement(
        elementId: number,
        action:
            | 'click'
            | 'fill'
            | 'check'
            | 'hover'
            | 'focus'
            | 'scroll'
            | 'select_option',
        value?: string, // Used for fill, select_option
        checked?: boolean // Used for check
    ): Promise<string> {
        await this.ensureInitialized();
        if (typeof elementId !== 'number' || elementId <= 0) {
            const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Invalid elementId (${elementId}) provided for action '${action}'.`;
            console.error(errorMsg);
            return Promise.resolve(errorMsg); // Return error string directly
        }
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting action '${action}' on element ID ${elementId}...`
        );
        try {
            const result = await sendWsCommand('interact_element', this.tabId, {
                elementId,
                action,
                value,
                checked,
            });
            let message = String(result);
            // Add recommendations based on action
            if (
                !message.startsWith('[browser_utils] Error:') &&
                !message.toLowerCase().includes('error')
            ) {
                switch (action) {
                    case 'click':
                    case 'select_option':
                        message +=
                            " IMPORTANT: Page state might have changed. Consider calling get_page_content('interactive').";
                        break;
                    case 'hover':
                        message +=
                            " Tooltips or menus might now be visible. Consider calling get_page_content('interactive').";
                        break;
                    case 'focus':
                        message +=
                            " Subsequent 'press' or 'type' actions may target this element.";
                        break;
                }
            }
            return message;
        } catch (error: any) {
            return this.logError(`interactElement (${action})`, error, {
                elementId,
                value,
                checked,
            });
        }
    }

    async clickElement(elementId: number): Promise<string> {
        return this.interactElement(elementId, 'click');
    }

    async fillField(elementId: number, value: string): Promise<string> {
        if (value === undefined || value === null) {
            return `[browser_utils] Tab ${this.tabId}: Error: 'value' parameter must be provided for 'fillField'.`;
        }
        return this.interactElement(elementId, 'fill', value);
    }

    async checkElement(elementId: number, checked: boolean): Promise<string> {
        if (checked === undefined || checked === null) {
            return `[browser_utils] Tab ${this.tabId}: Error: 'checked' parameter (true/false) must be provided for 'checkElement'.`;
        }
        return this.interactElement(elementId, 'check', undefined, checked);
    }

    async hoverElement(elementId: number): Promise<string> {
        return this.interactElement(elementId, 'hover');
    }

    async focusElement(elementId: number): Promise<string> {
        return this.interactElement(elementId, 'focus');
    }

    async scrollElement(elementId: number): Promise<string> {
        return this.interactElement(elementId, 'scroll');
    }

    async selectOption(elementId: number, value: string): Promise<string> {
        if (value === undefined || value === null) {
            return `[browser_utils] Tab ${this.tabId}: Error: 'value' parameter (option value, text, or label) must be provided for 'selectOption'.`;
        }
        return this.interactElement(elementId, 'select_option', value);
    }

    /**
     * Sends an arbitrary debug command to the Chrome DevTools Protocol
     * @param method The CDP method to call (e.g., 'Page.captureScreenshot', 'DOM.getDocument')
     * @param commandParams Optional parameters for the CDP method
     * @returns Promise resolving to a result string or error message
     */
    async debugCommand(
        method: string,
        commandParams?: object
    ): Promise<string> {
        await this.ensureInitialized();
        if (!method || typeof method !== 'string') {
            const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Valid method name is required for 'debugCommand'.`;
            console.error(errorMsg);
            return Promise.resolve(errorMsg);
        }
        console.log(
            `[browser_utils] Tab ${this.tabId}: Executing debug command '${method}'...`
        );
        try {
            const result = await sendWsCommand('debug_command', this.tabId, {
                method,
                commandParams,
            });
            // Result could be any object, so we JSON stringify if it's not a string
            return typeof result === 'string'
                ? result
                : JSON.stringify(result, null, 2);
        } catch (error: any) {
            return this.logError('debugCommand', error, {
                method,
                commandParams,
            });
        }
    }

    /**
     * Switches the agent's tab or focuses on a specific tab
     * @param type Type of tab operation to perform
     * @param tabId Tab ID for 'id' or 'focus' operations
     * @returns Result message from the bridge/extension or an error message string
     */
    async switchTab(
        type: 'active' | 'new' | 'id' | 'focus',
        tabId?: string
    ): Promise<string> {
        await this.ensureInitialized();
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting tab operation '${type}'...`
        );

        try {
            // Handle the focus case directly using existing focusTab method
            if (type === 'focus' && tabId) {
                const chromeTabId = Number(tabId);
                if (isNaN(chromeTabId) || chromeTabId <= 0) {
                    const errorMsg = `[browser_utils] Tab ${this.tabId}: Error: Invalid Chrome tab ID (${tabId}) for focus operation.`;
                    console.error(errorMsg);
                    return errorMsg;
                }
                return await this.focusTab(chromeTabId);
            }

            // Handle other tab switch operations
            const result = await sendWsCommand('switch_tab', this.tabId, {
                type,
                tabId,
            });

            this.initialized = true;
            this.chromeTabId = result?.tabId || null; // Store chromeTabId if provided
            return String(result);
        } catch (error: any) {
            return this.logError(
                type === 'focus' ? 'focusTab' : 'switchTab',
                error
            );
        }
    }

    /**
     * Closes the dedicated browser tab and cleans up resources on the extension side.
     * @returns Confirmation message or error.
     */
    async closeSession(): Promise<string> {
        // No need to ensureInitialized, we want to close even if initialization failed
        console.log(
            `[browser_utils] Tab ${this.tabId}: Requesting session closure...`
        );
        try {
            const result = await sendWsCommand(
                'close_agent_session',
                this.tabId
            );
            this.initialized = false; // Mark as not initialized after closing
            this.chromeTabId = null;
            console.log(
                `[browser_utils] Tab ${this.tabId} session closed successfully.`
            );
            return String(result);
        } catch (error: any) {
            // Still mark as uninitialized even if close command fails (e.g., tab already gone)
            this.initialized = false;
            this.chromeTabId = null;
            return this.logError('closeSession', error);
        }
    }
}

// --- Tool Definition Helper (If used by your framework) ---
// Keep these if your agent framework uses them to define tool schemas.
// Note: The actual functions called are now methods on AgentBrowserSession instance.
// You'll need to adapt how your agent framework gets and uses these tools.
// It should now call `getAgentBrowserSession(agentId)` and then use the methods
// on the returned session object.

// Example:
// const agentSession = getAgentBrowserSession('agent-007');
// await agentSession.initialize();
// const content = await agentSession.get_page_content();
// const navResult = await agentSession.navigate('https://google.com');

// --- Agent Session Cache ---
const activeSessions = new Map<string, AgentBrowserSession>();

/**
 * Closes all active browser sessions and clears the session cache.
 * Useful for graceful shutdown or cleanup.
 *
 * @returns Promise that resolves when all sessions are closed
 */
export async function closeAllSessions(): Promise<void> {
    console.log(
        `[browser_utils] Closing all ${activeSessions.size} active browser sessions...`
    );

    const closePromises = Array.from(activeSessions.values()).map(session => {
        return session.closeSession().catch(err => {
            console.error('[browser_utils] Error closing session:', err);
        });
    });

    await Promise.all(closePromises);
    activeSessions.clear();
    console.log('[browser_utils] All sessions closed.');
}

// --- Factory Function for Agent Sessions ---

/**
 * Creates or retrieves a browser session manager for a specific tab.
 * Maintains a cache of sessions so repeated calls with the same tabId
 * return the same instance (unless it has been closed).
 *
 * @param tabId A unique identifier for the tab.
 * @returns An AgentBrowserSession instance for the given tabId.
 */
export function getAgentBrowserSession(
    tabId: string,
    startUrl?: string
): AgentBrowserSession {
    if (!tabId) {
        throw new Error('Tab ID cannot be empty.');
    }

    // Return the existing session if it's in the cache
    const existingSession = activeSessions.get(tabId);
    if (existingSession) {
        return existingSession;
    }

    // Create a new session
    const session = new AgentBrowserSession(tabId, startUrl);

    // Monkey-patch closeSession to remove from cache when closed
    const originalClose = session.closeSession.bind(session);
    session.closeSession = async function (): Promise<string> {
        activeSessions.delete(tabId);
        return originalClose();
    };

    // Add to cache
    activeSessions.set(tabId, session);
    return session;
}

// --- Initial Connection Attempt ---
// Attempt to connect when the module loads. Errors will be handled by reconnect logic.
connectWebSocket().catch(err => {
    console.error(
        '[browser_utils] Initial WebSocket connection failed:',
        err.message
    );
    // Reconnect will be scheduled by the error/close handler in connectWebSocket
});

// --- Graceful Shutdown ---
// Attempt to close sessions on exit, though this might not always run.
process.on('SIGINT', async () => {
    console.log(
        '[browser_utils] Received SIGINT. Attempting to close active sessions...'
    );
    await closeAllSessions();
    if (wsClient) {
        wsClient.close();
    }
    process.exit(0);
});
