/**
 * Custom Tool Utilities
 *
 * Utilities for creating, modifying, and managing dynamic tools.
 * Custom tools are created on demand by agents and stored in a database.
 * Each agent only has access to tools it created or that are specifically
 * relevant to its current task.
 */

import * as fs from 'fs';
import * as path from 'path';
import { embed } from './embedding_utils.js';
import { createToolFunction } from './tool_call.js';
// Import only what we use from model_data.js
import { getHelperDescriptions } from './tool_context.js';
import { quick_llm_call } from './llm_call_utils.js';
import { ToolFunction, ToolParameterType } from '../types/shared-types.js';
import {
    CustomTool,
    addCustomTool,
    getCustomToolByName,
    searchCustomToolsByEmbedding,
} from './progress_db.js';
import { get_working_dir } from './file_utils.js';
import { executeToolInSandbox } from './tool_executor.js';
import { sendStreamEvent } from './communication.js';
import { v4 as uuidv4 } from 'uuid';
import type { ToolCall } from 'openai/resources/beta/threads/runs/steps.js';

/**
 * Represents a tool generated by the CodeAgent
 */
interface GeneratedTool {
    name: string; // e.g., "translate_text"
    description: string; // plain-language description
    parameters_json: object; // JSON schema
    implementation: string; // TypeScript function body as string
}

// Import the tool executor for consistent execution of both tools and scripts

// Maximum size of feedback message to prevent prompt size explosion
const MAX_FEEDBACK_SIZE = 2500;

// Maximum number of custom tools an agent can have to prevent overwhelming the agent
export const MAX_AGENT_TOOLS = 20;

// Cache generated tools to avoid unnecessary DB lookups during a session
const toolCache = new Map<string, ToolFunction>();

// Per-agent cache of custom tools
// Keys are agent_ids, values are arrays of custom tool functions
export const agentToolCache = new Map<string, ToolFunction[]>();

// No need for forward declarations, we'll just move these functions up in the file

/**
 * Retrieve basic custom tool creation functions
 * This function returns only the CUSTOM_TOOL function.
 * @returns An array of custom tool functions
 */
export function getCustomTools(): ToolFunction[] {
    return [
        createToolFunction(CUSTOM_TOOL, 'Solve a problem with a custom tool.', {
            problem: {
                type: 'string',
                description: 'What problem does this tool need to solve?',
            },
            input: {
                type: 'string',
                description:
                    'Either a string, or JSON object (stringified) which contains all the information needed by the tool to solve the problem. This input will be run once the tool is created. It will also be used as a guide for the input parameters for future uses of the tool.',
            },
            result: {
                type: 'string',
                description:
                    'What should this tool return, or what task should it perform?',
            },
        }),
    ];
}

/**
 * Get agent-specific tools for a particular agent
 *
 * @param agent_id The ID of the agent to get tools for
 * @returns Array of tool functions specific to this agent
 */
export function getAgentSpecificTools(agent_id: string): ToolFunction[] {
    const tools: ToolFunction[] = [];

    // Add modify_tool only if this agent has custom tools
    if (
        agentToolCache.has(agent_id) &&
        agentToolCache.get(agent_id)!.length > 0
    ) {
        tools.push(
            createToolFunction(
                modify_tool,
                'Modify an existing custom tool. This will create a new version of the tool with the changes.',
                {
                    name: {
                        type: 'string',
                        description: 'The name of the existing tool to modify.',
                    },
                    modification_request: {
                        type: 'string',
                        description:
                            'Description of the changes to make to the tool.',
                    },
                },
                'The modified tool with the requested changes.'
            )
        );
    }

    // Add any cached tools for this agent
    if (agentToolCache.has(agent_id)) {
        tools.push(...agentToolCache.get(agent_id)!);
    }

    return tools;
}

/**
 * Get relevant custom tools based on embedding similarity to a query
 * @param embedding The embedding vector to use for similarity search
 * @param threshold Similarity threshold (default: 0.7)
 * @param limit Maximum number of tools to return (default: 3)
 * @returns Array of tool functions that match the embedding
 */
export async function getRelevantCustomTools(
    embedding: number[],
    threshold: number = 0.7,
    limit: number = 3
): Promise<ToolFunction[]> {
    try {
        // Search database for similar tools
        const similarTools = await searchCustomToolsByEmbedding(
            embedding,
            threshold,
            limit
        );

        // Convert DB tools to ToolFunction objects
        return similarTools.map(tool => convertCustomToolToToolFunction(tool));
    } catch (error) {
        console.error('Error fetching relevant custom tools:', error);
        return [];
    }
}

/**
 * Helper function to infer a parameter schema from a sample input
 * @param sample The sample input string
 * @returns A JSON schema object defining the parameters
 */
/**
 * Maps JavaScript types to ToolParameterType values
 * @param value Value to determine the type for
 * @returns ToolParameterType string
 */
function getParameterType(value: any): ToolParameterType {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';

    // Standard JS types that match ToolParameterType
    const jsType = typeof value;
    if (jsType === 'string') return 'string';
    if (jsType === 'number') return 'number';
    if (jsType === 'boolean') return 'boolean';

    // Default for objects and anything else
    return 'object';
}

/**
 * Convert a string to snake_case
 * @param str The string to convert
 * @returns The snake_case version of the string
 */
function toSnakeCase(str: string): string {
    return (
        str
            // Handle camelCase
            .replace(/([a-z])([A-Z])/g, '$1_$2')
            // Handle PascalCase
            .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')
            // Replace spaces, hyphens, and dots with underscores
            .replace(/[\s-]+|\.+/g, '_')
            // Convert to lowercase
            .toLowerCase()
    );
}

/**
 * Infer a parameter schema from a sample input
 * Converting property names to snake_case for consistency
 * @param sample The sample input string
 * @returns A JSON schema object defining the parameters
 */
function inferSchemaFromSample(sample: string): object {
    try {
        const obj = JSON.parse(sample);

        // Create a mapping from original keys to snake_case keys
        const keyMapping = Object.keys(obj).reduce(
            (map, key) => {
                map[key] = toSnakeCase(key);
                return map;
            },
            {} as Record<string, string>
        );

        // Store the mapping as a property in the schema for later use
        const schema = {
            type: 'object',
            properties: Object.fromEntries(
                Object.keys(obj).map(k => [
                    keyMapping[k],
                    {
                        type: getParameterType(obj[k]),
                        description: `The ${k} parameter`,
                        originalName: k, // Store original name for mapping
                    },
                ])
            ),
            required: Object.keys(obj).map(k => keyMapping[k]),
            // Add the key mapping to the schema for use in prepareArguments
            keyMapping: keyMapping,
        };

        return schema;
    } catch {
        // Not JSON, use a single string parameter
        return {
            type: 'object',
            properties: {
                input: {
                    type: 'string',
                    description: 'Input string to process',
                },
            },
            required: ['input'],
        };
    }
}

/**
 * Unified resolver for tool specifications
 * Handles both new tool creation and tool modification cases
 *
 * @param params Configuration parameters for the specification resolution
 * @returns Promise resolving to a tool spec including adapted parameter values
 */
async function _resolveToolSpecification(params: {
    problemDescription: string; // For new: problem; For modify: modification_request
    sampleInputForNewTool?: string; // Original input string, only for new tools
    initialSchemaForNewToolJson?: string; // JSON.stringify(inferSchemaFromSample(input)), only for new tools
    desiredResultForNewTool?: string; // Original result string, only for new tools
    existingToolSpec?: {
        // Only for modifications
        name: string;
        description: string;
        parameters_json: object; // Parsed JSON, not string
    };
}): Promise<{
    name: string;
    description: string;
    parameters_json: object;
    final_parameter_values: object;
}> {
    // Determine whether this is a new tool or modification
    const isModification = !!params.existingToolSpec;

    // Set up the context for the LLM call
    let promptContext = '';
    if (isModification) {
        promptContext = `CONTEXT: "You are modifying an existing tool specification."
MODIFICATION REQUEST: ${params.problemDescription}
EXISTING TOOL NAME: ${params.existingToolSpec!.name}
EXISTING TOOL DESCRIPTION: ${params.existingToolSpec!.description}
EXISTING TOOL PARAMETERS (JSON): ${JSON.stringify(params.existingToolSpec!.parameters_json, null, 2)}`;
    } else {
        promptContext = `CONTEXT: "You are creating a brand new tool specification."
PROBLEM: ${params.problemDescription}
SAMPLE INPUT: ${params.sampleInputForNewTool}
INITIAL INFERRED SCHEMA: ${params.initialSchemaForNewToolJson}
DESIRED RESULT: ${params.desiredResultForNewTool}`;
    }

    // Call the LLM to generate the specification
    const response = await quick_llm_call(
        promptContext, // Pass the dynamically assembled context
        null,
        {
            name: 'SpecificationAgent',
            description:
                'Generate or modify a tool specification based on the problem and context.',
            instructions: `You are designing a tool specification. Based on the provided information, your goal is to define a robust and potentially more useful tool.

YOUR PLAN:
1. **Analyze:** Please think through the intent of the tool and consider the underlying problem it is trying to solve. ${
                isModification
                    ? 'The existing specification may be sufficient, but consider if the modification request implies a need for generalization.'
                    : 'The provided schema may be the best option, but if you can think of a more general or useful version of the tool, please do so.'
            }
Do not go too far from the original schema - ${
                isModification
                    ? "the existing tool's functionality should still be preserved with the requested changes."
                    : 'the provided input should still work with minor modifications.'
            }

2. **Name & Description (name, description):** ${
                isModification
                    ? "Update or keep the name and description based on the modification request. Only change the name if there's a clear need for generalization or it's explicitly requested."
                    : "Propose a concise, descriptive snake_case name and a clear description for the tool, based on your final analysis. If the initial request is very specific (e.g., 'screenshot yahoo.com'), consider if a more general name (e.g., 'take_website_screenshot') is appropriate."
            }

3. **Parameters Schema (parameters_json):** Define the JSON schema for the tool's parameters. This schema should support the final version of the tool. ${
                isModification
                    ? 'Update the parameters as needed based on the modification request. Consider if new parameters are needed or existing ones should be changed.'
                    : "For instance, if the sample input implies a hardcoded URL, your schema should likely include a 'url' parameter. If you do not need to generalize the schema, you can use the initial schema as is."
            }

4. **Adapted Parameter Values (final_parameter_values):** This is critical. Create an object where keys are the parameter names from YOUR proposed parameters_json, and values are the specific values ${
                isModification
                    ? 'that would be needed to test the modified tool based on the modification request.'
                    : "extracted or inferred from the original SAMPLE_INPUT that would allow the generalized tool to fulfill the original specific request. (e.g., if your schema has 'url' and 'filepath', and sample input was for Yahoo, final_parameter_values might be {'url': 'https://yahoo.com', 'filepath': 'default_path.png'})."
            }

${
    isModification
        ? "If the modification doesn't change the parameter schema, simply provide values that would be suitable for testing the modified version."
        : 'If no generalization seems necessary, you can refine the initial input schema and still provide final_parameter_values based on the original input.'
}

WARNING:
DO NOT generalize the function so far that you cannot infer the correct final parameter values. The goal is to create a tool that can be used in the future with different inputs, but still works for the original request or with the requested modifications.

RESULT:
Return ONLY valid JSON containing name, description, parameters_json, and final_parameter_values.`,
            modelClass: 'reasoning_mini',
            modelSettings: {
                force_json: true,
                json_schema: {
                    type: 'object',
                    properties: {
                        name: {
                            type: 'string',
                            description:
                                'snake_case name of the tool - up to 6 words - be descriptive',
                        },
                        description: {
                            type: 'string',
                            description:
                                'A couple of sentences describing what the tool does. Focus on the input and output. A couple of sentences is enough.',
                        },
                        parameters_json: {
                            type: 'object',
                            description:
                                'The JSON schema for the tool parameters, potentially generalized beyond the original sample input. You may add new parameters or modify existing ones.',
                        },
                        final_parameter_values: {
                            type: 'object',
                            description:
                                'An object mapping the parameter names from parameters_json to specific values derived from the original sample input or modification request.',
                        },
                    },
                    required: [
                        'name',
                        'description',
                        'parameters_json',
                        'final_parameter_values',
                    ],
                },
            },
        }
    );

    try {
        // Parse the response
        const spec = JSON.parse(response);

        // Validate the spec has all required fields
        if (
            !spec.name ||
            !spec.description ||
            !spec.parameters_json ||
            !spec.final_parameter_values
        ) {
            throw new Error(
                'Generated specification is missing required fields'
            );
        }

        // Return the full specification with adapted parameter values
        return {
            name: spec.name,
            description: spec.description,
            parameters_json: spec.parameters_json,
            final_parameter_values: spec.final_parameter_values,
        };
    } catch (error) {
        console.error('Error parsing tool spec:', error);
        throw new Error(
            `Failed to generate valid tool specification: ${error instanceof Error ? error.message : String(error)}`
        );
    }
}

/**
 * Generate a tool specification (name, description, parameters)
 * Leverages an LLM to create a potentially generalized tool based on the problem description,
 * sample input, and desired result. The returned specification includes adapted parameter values
 * to test the tool with the original request.
 *
 * @param problem Description of the problem to solve
 * @param input Sample input
 * @param result Description of expected result
 * @returns Promise resolving to a tool spec and adapted parameter values
 */
async function generateToolSpec(
    problem: string,
    input: string,
    result: string
): Promise<{
    name: string;
    description: string;
    parameters_json: object;
    final_parameter_values: object;
}> {
    // Infer parameter schema from the sample input first
    const inferredSchema = inferSchemaFromSample(input);
    const prettyParams = JSON.stringify(inferredSchema, null, 2);

    // Use the unified resolver for new tool specifications
    return _resolveToolSpecification({
        problemDescription: problem,
        sampleInputForNewTool: input,
        initialSchemaForNewToolJson: prettyParams,
        desiredResultForNewTool: result,
    });
}

/**
 * Generates and validates a tool implementation
 * This internal helper function is used by both CUSTOM_TOOL and modify_tool
 * to avoid code duplication between the two.
 *
 * @param toolSpec The specification of the tool to generate/validate
 * @param agent_id The agent ID
 * @param problem The problem description (for new tools) or modification request (for modifications)
 * @param input Sample input for testing the tool
 * @param result Expected result description
 * @param existingImplementation Optional existing implementation (for modify_tool)
 * @param feedback Optional feedback from previous attempt
 * @param maxAttempts Maximum number of generation attempts
 * @returns A Promise resolving to the generated tool object or null if failed
 */
async function _generateAndValidateImplementation(
    toolSpec: {
        name: string;
        description: string;
        parameters_json: object;
    },
    agent_id: string,
    problem: string,
    input: string,
    result: string,
    existingImplementation?: string,
    feedback?: string | null,
    maxAttempts: number = 10
): Promise<GeneratedTool | null> {
    let attempts = 0;
    let executionResult: string | null = null;
    // No need to track separately, we'll return the output directly

    // Get the parameter keys from the toolSpec
    const paramKeys = Object.keys(
        (toolSpec.parameters_json as any).properties || {}
    );

    // Generate and test the implementation with multiple attempts if needed
    while (attempts < maxAttempts) {
        attempts++;
        console.log(`Tool generation attempt ${attempts}/${maxAttempts}`);

        // Build prompt for CodeAgent to implement the function
        const prettyParams = JSON.stringify(toolSpec.parameters_json, null, 2);

        const absolutePath = path.join(
            get_working_dir(),
            `${toolSpec.name}_${attempts}.ts`
        );

        // Build the code prompt, instructing Claude to:
        // 1. Save to a file named after the tool
        // 2. Use the right function signature
        // 3. Output the filename as the last line
        let codePrompt = `Please create a TypeScript function that implements the following specification:
NAME: ${toolSpec.name}
DESCRIPTION: ${toolSpec.description}
PARAMETERS
${prettyParams}

---
HELPER FUNCTIONS - The following TypeScript declarations define helper functions available in the global scope:

${getHelperDescriptions().join('\n\n')}

---
SPECIFICATION - Your tool implementation MUST follow this SPECIFICATION:

/**
 * ${toolSpec.description}
 *
 * @param ${paramKeys.length > 0 ? paramKeys.join(' Description of first parameter\\n * @param ') : ''}${paramKeys.length > 0 ? ' Description of last parameter' : ''}
 * @returns Promise<string>
 */
async function ${toolSpec.name}(${paramKeys.length > 0 ? paramKeys.map(key => `${key}: ${(toolSpec.parameters_json as any).properties[key]?.type || 'any'}`).join(', ') : ''}): Promise<string> {
    // Your implementation here
    return 'Final status or result';
}

---
EXAMPLE IMPLEMENTATION

\`\`\`typescript
// If you need to use Node.js built-in modules directly, you can import them:
import fs from 'fs';

// For all helper functions like read_file and quick_llm_call, no import is needed as they are globally available
// Include the TypeScript declaration of all helper functions you'll use at the top of your file for type-safety and linting
declare function read_file(
    file_path: string,
    line_start?: number,
    line_end?: number,
    max_chars?: number
): Promise<string>;

declare function quick_llm_call(
    messages: string | Array<{ type: 'message'; role: 'user' | 'system' | 'developer'; content: string }>,
    modelClass: 'reasoning_mini' | 'reasoning' | 'code' | 'writing' | 'summary' | 'vision' | 'search' | 'image_generation',
): Promise<string>;

/**
 * An example implementation of using tools to summarize a file
 *
 * @param filePath string The path to the file to summarize
 * @returns Promise<string> containing the result
 */
async function example_file_summary(filePath: string): Promise<string> {
    // EXAMPLE: Reading a file using the read_file helper function
    let fileContent = '';
    try {
        fileContent = await read_file(filePath);
        console.log(\`File \${filePath} content length:\`, fileContent.length);
    }
    catch (error) {
        // You can return errors as strings or throw them
        return \`ERROR could not read file \${filePath}: \${error}\`;
    }

    // EXAMPLE: Using an LLM to process content
    const llmResponse = await quick_llm_call('Summarize this document: '+fileContent, 'summary');
    const llmSummary = llmResponse.substring(0, 100);
    // errors throw will be handled automatically by the tool executor

    // EXAMPLE: Using node.js modules
    fs.unlink(filePath, () => {});

    return llmSummary;  // Always return a string
}
\`\`\`

---
FILE OUTPUT REQUIREMENT:
You MUST write your complete function implementation to a file located at ${absolutePath}`;

        if (feedback) {
    codePrompt += `

---
TEST FAILURE:
Another agent previously attempted to implement this function, but it failed. Here is the feedback from that attempt:
\`\`\`
${feedback}
\`\`\`

Please fix the code based on this feedback. If you need to re-rewrite the entire function, please do so.`;
        }

        // Add previous implementation and feedback if available
        if (existingImplementation) {
            codePrompt += `

---
FAILED CODE:
This is the existing implementation, which needs to be modified:
\`\`\`typescript
${existingImplementation}
\`\`\``;
        }


        // Prepare the arguments string for the magi-run-tool command in the prompt
        let cliTestArgsString = '';
        try {
            const finalParamsObject = JSON.parse(input); // 'input' is adaptedInputString from final_parameter_values
            const orderedArgsForCli: string[] = [];

            if (paramKeys.length > 0 && (typeof finalParamsObject !== 'object' || finalParamsObject === null)) {
                // This case implies that paramKeys exist, but the input (final_parameter_values)
                // is not an object that can provide these keys. This might happen if the schema
                // expects e.g. { "input_string": "value" } but final_parameter_values was just "value".
                // If there's only one paramKey, assume finalParamsObject is its direct value.
                if (paramKeys.length === 1) {
                    orderedArgsForCli.push(JSON.stringify(finalParamsObject));
                } else {
                    // Multiple params expected, but input is not an object. This is ambiguous.
                    // Fallback to old behavior for safety, though this state indicates an upstream issue.
                    // eslint-disable-next-line quotes
                    console.warn('CLI Warning: Params expected by schema, but final_parameter_values not an object. Input: ' + input); // Ensure single quotes
                    throw new Error('Ambiguous input for CLI test string with multiple parameters.');
                }
            } else if (typeof finalParamsObject === 'object' && finalParamsObject !== null) {
                 for (const key of paramKeys) {
                    // paramKeys are from the schema. finalParamsObject is from LLM-generated final_parameter_values.
                    // It's assumed keys in finalParamsObject align with paramKeys.
                    const value = Object.prototype.hasOwnProperty.call(finalParamsObject, key) ? finalParamsObject[key] : undefined;
                    orderedArgsForCli.push(JSON.stringify(value));
                }
            }
            // If paramKeys is empty, orderedArgsForCli will be empty.
            // If finalParamsObject was not an object and paramKeys was also empty, it's also fine.

            cliTestArgsString = orderedArgsForCli.join(' ');

        } catch (e) {
            // Fallback if JSON.parse(input) fails or other issues.
            // This is a safety net; 'input' should be valid JSON from final_parameter_values.
            console.warn('Could not construct CLI test args string from input \'' + input + '\' due to: ' + (e instanceof Error ? e.message : String(e)) + '. Falling back to single-quoted input for prompt.');
            cliTestArgsString = `'${input}'`; // Original way
        }
        // Ensure there's no leading space if cliTestArgsString is empty (no params)
        const magiRunToolCommand = '> magi-run-tool ' + agent_id + ' ' + absolutePath + (cliTestArgsString ? ' ' + cliTestArgsString : '');

        codePrompt += `

---
SCRIPTS & TESTING:
ALWAYS test your implementation by running the following command:
${magiRunToolCommand}

---
PLAN:
1. Think through the problem fully and consider the full intent of the request.
2. Write the full async TypeScript function implementation for this tool.
3. You MUST save your final code as a single file located at ${absolutePath}
4. TEST, TEST, TEST using
${magiRunToolCommand}
- fix any issues and resolve the underlying problem, never add mock code or placeholders.
5. Make the VERY LAST LINE of your output only the string '[complete]'

WARNINGS:
Please ensure that your function solves the intent of the problem and works for general cases, not just the sample input provided.
Where possible, test your function before returning it. Do not return mock code or placeholders. If you encounter any issues, please explain the underlying issue.

FAILURE:
If you determine that this task cannot be completed, instead of providing code, respond with ONLY:
ERROR: <clear explanation of why the task cannot be completed>`;

            const codeMessage = `
PROBLEM TO SOLVE:
${problem}

SAMPLE INPUT:
${input}

DESIRED RESULT:
${result}`;

        console.log(`\n\n***Code prompt for CodeAgent:\n${codePrompt}`);
        console.log(`\n\n***Code message for CodeAgent:\n${codeMessage}`);

        // Generate the implementation
        const response = await quick_llm_call(
            codeMessage,
            null,
            {
                name: 'CustomToolAgent',
                description:
                    'Generate a TypeScript function implementation for a custom tool.',
                instructions: codePrompt,
                modelClass: 'code',
            },
            agent_id
        );

        // Extract the implementation from the file written by Claude
        try {
            // Resolve the file path relative to the current working directory
            console.log(`Looking for file at: ${absolutePath}`);

            // Check if the file exists
            if (!fs.existsSync(absolutePath)) {
                throw new Error(
                    `Implementation file not found: ${absolutePath}`
                );
            }

            // Read the file content
            const implementation = fs.readFileSync(absolutePath, 'utf-8');

            // Validate that it contains a function definition
            if (
                !implementation.includes('function') ||
                !implementation.includes(toolSpec.name)
            ) {
                throw new Error(
                    'Implementation file does not contain a valid function definition'
                );
            }

            console.log(
                `Successfully read implementation from file: ${absolutePath}`
            );

            // Extract parameter names and verify they match the schema
            const funcParams = extractParameterNames(implementation);

            // Verify that all required parameters are present in the function signature
            const missingParams = paramKeys.filter(
                key => !funcParams.includes(key)
            );

            if (missingParams.length > 0) {
                throw new Error(
                    `Function signature is missing parameters: ${missingParams.join(', ')}`
                );
            }

            // Create a temporary tool object
            const generatedTool: GeneratedTool = {
                name: toolSpec.name,
                description: toolSpec.description,
                parameters_json: toolSpec.parameters_json,
                implementation: implementation,
            };

            // Prepare arguments by mapping to parameter names, using the parameter schema
            const args = prepareArguments(
                implementation,
                input,
                toolSpec.parameters_json
            );

            const toolCall: ToolCall = {
                id: uuidv4(),
                type: 'function',
                function: {
                    name: toolSpec.name,
                    arguments: JSON.stringify(args),
                    output: null,
                },
            }

            sendStreamEvent({
                type: 'tool_start',
                tool_calls: [toolCall],
            });

            // Execute the function in a safe sandbox with the agent context
            console.log(`Testing tool '${toolSpec.name}' with sample input...`);
            executionResult = await executeToolInSandbox({
                codeString: implementation,
                functionName: toolSpec.name,
                agentId: agent_id || '',
                args: args,
            });

            sendStreamEvent({
                type: 'tool_done',
                tool_calls: [toolCall],
                results: executionResult,
            })

            console.log(`Tool execution result: ${executionResult}`);

            // Use quick_llm_call with reasoning_mini to verify the result
            const verifierResult = await quick_llm_call(
                `PROBLEM: ${problem}

SAMPLE INPUT: ${input}

EXPECTED RESULT DESCRIPTION: ${result}

ACTUAL RESULT: ${executionResult}`,
                null,
                {
                    name: 'VerifierAgent',
                    description:
                        'Verify if the tool execution result meets expectations.',
                    instructions: `You are verifying if a TypeScript tool's execution result satisfies the expected outcome.
Does the actual result satisfy the intent of result description? Do not be overly strict, but fail will not solve the intent of problem.
Return only
"pass" if it satisfies expectations, or "fail: <reason>" explaining why it doesn't.
`,
                    modelClass: 'reasoning_mini',
                    modelSettings: {
                        temperature: 0.5, // Lower temperature for more deterministic evaluation
                    },
                },
                agent_id
            );

            // Check if the tool passed verification
            if (verifierResult.trim().toLowerCase().startsWith('pass')) {
                console.log('Tool verification passed!');
                // Success! Return the generated tool
                return generatedTool;
            } else {
                // Extract the reason for failure
                const failReason = verifierResult
                    .replace(/^fail:\s*/i, '')
                    .trim();
                console.log('Tool verification failed: ' + failReason);

                // Truncate feedback to prevent prompt explosion
                feedback =`Testing the tool failed due to the following reason:
${failReason}

Raw test results:
${executionResult}` ;
                if (feedback.length > MAX_FEEDBACK_SIZE) {
                    feedback =
                        feedback.substring(0, MAX_FEEDBACK_SIZE) +
                        '... (truncated)';
                }
                // Try again with the feedback
                continue;
            }
        } catch (error) {
            console.error('Error processing tool implementation:', error);
            console.error('Raw response:', response);
            feedback = `Error with implementation: ${error instanceof Error ? error.message : String(error)}`;
            // Try again with the feedback
            continue;
        }
    }

    console.error(
        `Failed to create a working tool after ${maxAttempts} attempts`
    );
    return null;
}

/**
 * Extract parameter names from a function signature
 * @param implementation The function implementation string
 * @returns Array of parameter names in order
 */
function extractParameterNames(implementation: string): string[] {
    const funcSignatureMatch = implementation.match(
        /function\s+\w+\s*\(([^)]*)\)/
    );
    return funcSignatureMatch
        ? funcSignatureMatch[1]
              .split(',')
              .map(p => {
                  // Trim, get part before ':', trim again, and remove trailing '?' for optional params
                  return p.trim().split(':')[0].trim().replace(/\?$/, '');
              })
              .filter(p => p.length > 0) // Filter out empty strings if any (e.g. trailing comma)
        : [];
}

/**
 * Prepare argument array based on function parameters and input.
 * This function assumes `inputString` is typically a JSON string representing an object
 * where keys are parameter names and values are their corresponding values.
 * It maps these values to an array of positional arguments based on the function signature.
 *
 * @param implementation Function implementation string (to extract parameter names)
 * @param inputString The input, usually a JSON string of an object (e.g., from `final_parameter_values`)
 * @param parametersSchema Optional schema, mainly for `keyMapping` if input keys differ from param names (e.g. original vs snake_case)
 * @returns Array of arguments matched to parameter positions
 */
function prepareArguments(
    implementation: string,
    inputString: string,
    parametersSchema?: any
): any[] {
    const paramNames = extractParameterNames(implementation); // e.g., ['url'] or ['url', 'filepath']

    if (paramNames.length === 0) {
        return []; // No parameters, return empty array
    }

    let inputObj: any;
    try {
        // Assume inputString is a JSON representation of the arguments object
        inputObj = JSON.parse(inputString);
    } catch (e) {
        // If inputString is not valid JSON:
        // If the function expects a single parameter, assume inputString is that direct value.
        if (paramNames.length === 1) {
            return [inputString];
        }
        // If multiple parameters are expected but inputString is not a parsable object,
        // this is an ambiguous situation. Log a warning and return undefined for all params.
        console.warn(
            `prepareArguments: inputString is not a valid JSON object string, but multiple parameters are expected by function ${implementation.substring(0, 100)}...`
        );
        return paramNames.map(() => undefined); // Or throw an error
    }

    // Ensure inputObj is an object, as properties will be accessed.
    if (typeof inputObj !== 'object' || inputObj === null) {
        // If inputObj is not an object (e.g., a string, number, array from JSON.parse)
        // and the function expects a single parameter, pass inputObj as that single argument.
        if (paramNames.length === 1) {
            return [inputObj];
        }
        console.warn(
            `prepareArguments: Parsed input is not an object, but multiple parameters are expected by function ${implementation.substring(0, 100)}...`
        );
        return paramNames.map(() => undefined); // Or throw an error
    }

    const args: any[] = [];
    // keyMapping from schema might be used if inputObj keys are different from paramNames (e.g. originalName vs snake_case name)
    // However, final_parameter_values (usual source of inputObj) should use keys from the *final* parameters_json (which are snake_cased).
    const keyMapping = parametersSchema?.keyMapping || {};
    const reverseMapping: Record<string, string> = {};
    if (typeof keyMapping === 'object' && keyMapping !== null) {
        for (const [original, snakeCase] of Object.entries(keyMapping)) {
            if (typeof snakeCase === 'string') {
                 reverseMapping[snakeCase] = original as string;
            }
        }
    }


    for (const paramName of paramNames) {
        let valueFound = false;
        // 1. Direct match: paramName (from function signature) is a key in inputObj
        if (paramName in inputObj) {
            args.push(inputObj[paramName]);
            valueFound = true;
        }
        // 2. Via reverseMapping: paramName is snake_case, inputObj might have original_case key
        // This is less likely if inputObj comes from final_parameter_values which should use final (snake_case) keys.
        else if (
            reverseMapping[paramName] &&
            reverseMapping[paramName] in inputObj
        ) {
            args.push(inputObj[reverseMapping[paramName]]);
            valueFound = true;
        }

        if (!valueFound) {
            // If parameter is not found in inputObj, push undefined.
            // This maintains argument order and arity for the function call.
            args.push(undefined);
        }
    }
    return args;
}

/**
 * Create a custom tool based on a description using a two-step process:
 *
 * 1. First generate the tool specification (name, description, parameters)
 * 2. Then generate the implementation code
 *
 * The function:
 * 1. Searches for existing tools with a similar description
 * 2. If found, returns the existing tool
 * 3. If not found, uses a two-step process to create a new tool:
 *    a. Generate specs with a focused LLM call
 *    b. Generate implementation with CodeAgent
 * 4. Tests the tool with the provided input
 * 5. Verifies the result meets expectations
 * 6. If verification fails, loops back to fix the implementation
 * 7. Stores the working tool in the database
 * 8. Makes the tool immediately available to the calling agent
 *
 * @param inject_agent_id The ID of the agent creating the tool
 * @param problem A description of the problem the tool should solve
 * @param input Sample input for the tool to process
 * @param result Description of the expected result
 * @returns A string describing the created or found tool
 */
export async function CUSTOM_TOOL(
    inject_agent_id: string,
    problem: string,
    input: string,
    result: string
): Promise<string> {
    console.log(`Creating custom tool to solve ${problem}`);
    const MAX_ATTEMPTS = 10; // Maximum number of tool generation/fix attempts

    try {
        const description = `${problem} -> ${result}`;

        // Generate embedding for description once and reuse
        const embedding = await embed(description);

        // Search for similar existing tools (threshold: 0.8)
        const similarTools = await searchCustomToolsByEmbedding(
            embedding,
            0.8,
            1
        );

        // If a similar tool was found, return it
        if (similarTools.length > 0) {
            const existingTool = similarTools[0];
            console.log(`Found existing similar tool: ${existingTool.name}`);
            return `Found existing tool: ${existingTool.name}
Description: ${existingTool.description}
Parameters: ${existingTool.parameters_json}

This tool is now available in your toolset.`;
        }

        // No similar tool found, create a new one using CodeAgent
        console.log('No similar tool found, creating a new one...');

        // Generate tool spec first
        let toolSpec;
        let generatedTool: GeneratedTool | null = null;
        let toolFunction: ToolFunction | null = null;

        // Variable we'll use throughout the function
        let adaptedInputString = '{}';

        try {
            // Generate new spec with potential generalization and adapted values
            const toolSpecWithAdaptedValues = await generateToolSpec(
                problem,
                input,
                result
            );

            // Create a string version of the adapted values to use for testing
            adaptedInputString = JSON.stringify(
                toolSpecWithAdaptedValues.final_parameter_values
            );

            console.log(
                `Generated tool spec: ${toolSpecWithAdaptedValues.name}`
            );
            console.log(
                `Using adapted parameter values: ${adaptedInputString}`
            );

            // Extract the core tool spec to use with _generateAndValidateImplementation
            toolSpec = {
                name: toolSpecWithAdaptedValues.name,
                description: toolSpecWithAdaptedValues.description,
                parameters_json: toolSpecWithAdaptedValues.parameters_json,
            };

            // Use the helper function to generate and validate the implementation
            generatedTool = await _generateAndValidateImplementation(
                toolSpec,
                inject_agent_id,
                problem,
                adaptedInputString, // Use the adapted input values for testing
                result,
                undefined, // No existing implementation
                null, // No initial feedback
                MAX_ATTEMPTS
            );
        } catch (error) {
            console.error('Error generating tool spec:', error);
            return `Error generating tool specification: ${error instanceof Error ? error.message : String(error)}`;
        }

        // Check if we succeeded
        if (!generatedTool) {
            console.error(
                `Failed to create a working tool after ${MAX_ATTEMPTS} attempts`
            );
            return `Error creating custom tool after ${MAX_ATTEMPTS} attempts: Unable to generate a valid implementation`;
        }

        // At this point, the tool has been validated and works
        // Store it in the database
        const customTool: CustomTool = {
            name: generatedTool.name,
            description: generatedTool.description,
            parameters_json: JSON.stringify(generatedTool.parameters_json),
            implementation: generatedTool.implementation,
            embedding: embedding,
            version: 1,
            is_latest: true,
        };

        const toolId = await addCustomTool(customTool);
        console.log(`Added new custom tool with ID: ${toolId}`);

        // Create a tool function for immediate use
        toolFunction = convertCustomToolToToolFunction(customTool);

        // Execute the tool with the adapted parameter values to get the output for display
        const args = prepareArguments(
            generatedTool.implementation,
            adaptedInputString, // Use the adapted values, not the original input
            generatedTool.parameters_json
        );
        const output = await executeToolInSandbox({
            codeString: generatedTool.implementation,
            functionName: generatedTool.name,
            agentId: inject_agent_id || '',
            args: args,
        });

        // Add the tool to this agent's toolset
        if (inject_agent_id) {
            // Initialize the agent's tool cache if needed
            if (!agentToolCache.has(inject_agent_id)) {
                agentToolCache.set(inject_agent_id, []);
            }

            // Add the tool to the agent's cache
            const agentTools = agentToolCache.get(inject_agent_id)!;

            // Enforce the tool limit by removing the oldest one if needed
            if (agentTools.length >= MAX_AGENT_TOOLS) {
                agentTools.shift(); // Remove the oldest tool
            }

            // Add the new tool
            agentTools.push(toolFunction);
        }

        return `Created new tool: ${generatedTool.name}()
Description: ${generatedTool.description}
Parameters: ${JSON.stringify(generatedTool.parameters_json, null, 2)}
This tool is now available in your toolset.

This tool has already been run with the input you provided "${input}" and generated the output:
\`\`\`
${output}
\`\`\``;
    } catch (error) {
        console.error('Error in CUSTOM_TOOL:', error);
        return `Error creating custom tool: ${error instanceof Error ? error.message : String(error)}`;
    }
}

/**
 * Modify an existing custom tool
 *
 * @param inject_agent_id The ID of the agent modifying the tool
 * @param name The name of the existing tool to modify
 * @param modification_request Description of the modifications to make
 * @returns A string describing the modified tool
 */
export async function modify_tool(
    inject_agent_id: string,
    name: string,
    modification_request: string
): Promise<string> {
    console.log(
        `Modifying custom tool '${name}' with request: ${modification_request}`
    );

    try {
        // Get the existing tool
        const existingTool = await getCustomToolByName(name);

        if (!existingTool) {
            return `Error: Tool '${name}' not found. You must specify the exact name of an existing custom tool.`;
        }

        // Generate updated spec using the unified resolver
        try {
            // Parse the parameters_json from string to object
            const paramsJson =
                typeof existingTool.parameters_json === 'string'
                    ? JSON.parse(existingTool.parameters_json)
                    : existingTool.parameters_json;

            // Create the existing tool spec for _resolveToolSpecification
            const existingSpec = {
                name: existingTool.name,
                description: existingTool.description,
                parameters_json: paramsJson,
            };

            // Use the unified resolver to get updated spec with adapted parameter values
            const updatedSpec = await _resolveToolSpecification({
                problemDescription: modification_request,
                existingToolSpec: existingSpec,
            });

            // Get adapted parameter values as a string for testing
            const adaptedInputString = JSON.stringify(
                updatedSpec.final_parameter_values
            );
            console.log('Using adapted parameter values:', adaptedInputString);

            // Generate and validate the implementation using the helper function
            const generatedTool = await _generateAndValidateImplementation(
                updatedSpec, // Use the updated spec directly
                inject_agent_id,
                modification_request, // Use the modification request as the "problem"
                adaptedInputString, // Use the adapted input values for testing
                'A successfully modified tool that meets all requirements.', // Generic expected result
                existingTool.implementation, // Pass the existing implementation
                null, // No initial feedback
                10 // Maximum attempts
            );

            // Check if we got a valid implementation
            if (!generatedTool) {
                console.error(
                    'Failed to create a working modified tool after 10 attempts'
                );
                return 'Error modifying custom tool: Failed to generate a valid implementation.';
            }

            // Generate embedding for the new description
            const embedding = await embed(generatedTool.description);

            // Store the modified tool in the database with incremented version
            const customTool: CustomTool = {
                name: generatedTool.name,
                description: generatedTool.description,
                parameters_json: JSON.stringify(generatedTool.parameters_json),
                implementation: generatedTool.implementation,
                embedding: embedding,
                version: (existingTool.version || 1) + 1,
                is_latest: true,
            };

            const toolId = await addCustomTool(customTool);
            console.log(`Added modified custom tool with ID: ${toolId}`);

            // Convert the tool to a ToolFunction
            const toolFunction = convertCustomToolToToolFunction(customTool);

            // Update the agent's toolset with the modified version
            if (inject_agent_id && agentToolCache.has(inject_agent_id)) {
                const agentTools = agentToolCache.get(inject_agent_id)!;

                // Find and replace the old version of the tool if it exists
                const existingIndex = agentTools.findIndex(
                    t => t.definition.function.name === generatedTool.name
                );

                if (existingIndex >= 0) {
                    // Replace the old tool with the new version
                    agentTools[existingIndex] = toolFunction;
                } else {
                    // Add as a new tool if it doesn't exist
                    // Enforce the tool limit
                    if (agentTools.length >= MAX_AGENT_TOOLS) {
                        agentTools.shift(); // Remove the oldest tool
                    }
                    agentTools.push(toolFunction);
                }
            }

            return `Modified tool: ${generatedTool.name}
Description: ${generatedTool.description}
Parameters: ${JSON.stringify(generatedTool.parameters_json, null, 2)}

This modified tool is now available in your toolset.`;
        } catch (error) {
            console.error(
                'Error generating or validating modified tool:',
                error
            );
            return `Error modifying custom tool: ${error instanceof Error ? error.message : String(error)}`;
        }
    } catch (error) {
        console.error('Error in modify_tool:', error);
        return `Error modifying custom tool: ${error instanceof Error ? error.message : String(error)}`;
    }
}

/**
 * Convert a CustomTool database record to a ToolFunction
 * This creates an executable function from the stored implementation
 * @param tool The custom tool database record
 * @returns A ToolFunction that can be called by agents
 */
function convertCustomToolToToolFunction(tool: CustomTool): ToolFunction {
    // Check if we already have this tool in cache
    const cacheKey = `${tool.name}_v${tool.version}`;
    if (toolCache.has(cacheKey)) {
        return toolCache.get(cacheKey)!;
    }

    // Parse parameters JSON
    let parametersObj: object;
    try {
        parametersObj =
            typeof tool.parameters_json === 'string'
                ? JSON.parse(tool.parameters_json)
                : tool.parameters_json;
    } catch (error) {
        console.error(
            `Error parsing parameters_json for tool ${tool.name}:`,
            error
        );
        parametersObj = {
            type: 'object',
            properties: {},
            required: [],
        };
    }

    // Create a function wrapper that safely executes the implementation in a VM
    let functionImpl: (...args: any[]) => Promise<string>;
    try {
        // Create a function that will execute the implementation in a VM with agent context
        functionImpl = async (...args: any[]): Promise<string> => {
            try {
                // Extract agent_id from the first argument to pass to context
                const agent_id = args.length > 0 ? args[0] : undefined;
                return await executeToolInSandbox({
                    codeString: tool.implementation,
                    functionName: tool.name,
                    agentId: agent_id || '',
                    args: args,
                });
            } catch (error) {
                return `Error executing custom tool: ${error instanceof Error ? error.message : String(error)}`;
            }
        };
    } catch (error) {
        console.error(
            `Error creating function from implementation for tool ${tool.name}:`,
            error
        );
        functionImpl = async () =>
            `Error: Could not execute custom tool ${tool.name} due to implementation errors.`;
    }

    // Create the tool function
    const toolFunction = createToolFunction(
        functionImpl,
        tool.description,
        {}, // Empty param map since we'll set the full schema directly
        'Custom tool result'
    );

    // Directly set the parameters schema from the stored JSON
    toolFunction.definition.function.parameters = parametersObj as any;

    // Cache the tool function
    toolCache.set(cacheKey, toolFunction);

    return toolFunction;
}
